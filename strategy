How it is right now -------------------

Variables are allocated on the stack, and bound by an offset. So a
stack that looks like this:

(5) (nothing) (@[function])

might have the bindings

(x: 2) (y: 1) (f: 0)

The problem -----------

This makes closures difficult to implement without storing variables
seperately from the stack which is a complicated and bug-ridden way of
doing things

The solution ------------

Instead of using the stack as a space to allocate variables, we
allocate a new "Environment" with every call frame. This environment
has it's own dynamic storage (allocated with the collector) to
allocate variables into. Closures just contain a pointer to the
environment that they were defined in. This allows the garbage
collector to clean up closed variables that have become invalidated.
