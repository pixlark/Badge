<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Badge | Primarily functional programming language</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Badge" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Primarily functional programming language" />
<meta property="og:description" content="Primarily functional programming language" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="Badge" />
<script type="application/ld+json">
{"name":"Badge","description":"Primarily functional programming language","@type":"WebSite","url":"http://localhost:4000/","headline":"Badge","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=92f8ee3e534b0b688662c8fa8637130ca7bafeff">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">Badge</a></h1>
        
        

        <p>Primarily functional programming language</p>

        
        <p class="view"><a href="https://github.com/pixlark/Badge">View the Project on GitHub <small>pixlark/Badge</small></a></p>
        

        

        
      </header>
      <section>

      <h1 id="badge">Badge</h1>

<p>Badge is a mostly-functional programming language inspired variously by Scheme, OCaml, Python, and Rust.</p>

<h2 id="overview">Overview</h2>

<p>The main workhorse of Badge is the expression; pretty much everything you want to do can be expressed as a type of expression.</p>

<p>Here’s some examples of expressions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>15

nothing

if   12    % Evaluates to 6 (5 + 1)
then 5 + 1
else 2 + 3
</code></pre></div></div>

<p>One type of expression is the <strong>scope</strong>, denoted by a pair of curly brackets. Scopes can contain any number of <strong>statements</strong>, followed by an optional <strong>expression</strong> representing the final value of the scope itself. If no final expression is provided, the scope evaluates to <code class="highlighter-rouge">nothing</code>.</p>

<p>Here are some examples of scopes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	let x = 12.
	println(x).
	x + 1
} % Prints 12, evaluates to 13

{
	let y = { }.
	println(y).
} % Prints `nothing`, evaluates to `nothing`
</code></pre></div></div>

<p><strong>Statements</strong>, which can only exist at top-level or inside scopes, involve more imperative paradigms that any traditional programmer will be familiar with. They are terminated with a period (<code class="highlighter-rouge">.</code>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = 12.

println(x).

set x = nothing.

println(x).

% outputs 12, followed by `nothing`
</code></pre></div></div>

<p><strong>Lambdas</strong> are an important type of expression, and the only way to create new functions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let square = lambda (x) x * x.
println(square(3)). % Outputs 9
</code></pre></div></div>

<p>Lambdas are denoted with the <code class="highlighter-rouge">lambda</code> keyword, followed by a list of arguments in parentheses. The body of a lambda is an expression – any sufficiently complex lambda will likely require a scope as the body:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let complex = lambda (x, y) {
	let i = x + y.
	set i = i + 18 + x.
	set i = i * i.
	i
}.
println(complex(1, 2)). % Outputs 484
</code></pre></div></div>

<p>Built-in functions that can’t be expressed in terms of pure Badge are imported using the <code class="highlighter-rouge">@builtin</code> directive as so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let println = @builtin[println].
println(12). % Outputs 12
</code></pre></div></div>

<p><strong>Constructors and Objects</strong> are a simple way to store information together. The <code class="highlighter-rouge">@struct</code> directive is used to create new constructors:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let Point = @struct[x, y].
</code></pre></div></div>

<p>Constructors are used to instantiate objects:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let p = Point(1, 2).
</code></pre></div></div>

<p>And finally, the <code class="highlighter-rouge">'</code> operator is used to access the fields of an object:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>println(p'x).
println(p'y).
</code></pre></div></div>


      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/pixlark">pixlark</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>
